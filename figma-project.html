<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Figma Project</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 100%;
                height: 100vh;
                display: flex;
                align-items: center;
                justify-content: center;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 400px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
                border-radius: 12px;
                border: 1px solid rgba(0, 0, 0, 0.05);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: #f2f2f2;
                border: 0;
                box-sizing: border-box;
                font-size: 1rem;
                outline: 0;
                padding: 15px 30px 15px 15px;
                width: 100%;
                border-radius: 8px;
                margin-bottom: 0;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: transparent;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #000000;
                width: 100%;
                border: 0;
                padding: 12px 18px;
                color: #ffffff;
                font-size: 12px;
                font-weight: 600;
                cursor: pointer;
                border-radius: 0.375rem;
                transition: background-color 0.3s ease;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover:not(:disabled),
            .staticrypt-form .staticrypt-decrypt-button:active:not(:disabled),
            .staticrypt-form .staticrypt-decrypt-button:focus:not(:disabled) {
                background: rgba(0, 0, 0, 0.8);
                color: #ffffff;
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #f5f5f5;
                font-family: 'Nunito Sans', sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-bottom: 18px;
            }

            .lock-icon {
                display: flex;
                justify-content: center;
                margin-bottom: 1.5em;
            }

            .lock-icon svg {
                width: 24px !important;
                height: 24px !important;
            }

            .staticrypt-title {
                font-size: 2.5rem;
                font-weight: 700;
                margin-bottom: 0.5rem;
                color: #232323;
            }

            .staticrypt-instructions p:last-child {
                font-size: 1rem;
                color: #000000;
                margin: 0;
            }

            .staticrypt-form input[type="password"]::placeholder,
            input[type="text"]::placeholder {
                color: #a2a2a2;
            }

            .error-message {
                color: #dc3545;
                font-size: 0.8rem;
                margin-top: 8px;
                margin-bottom: 0;
                display: none;
                text-align: left;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
                color: #666;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .back-button-container {
                position: fixed;
                top: 20px;
                left: 20px;
                z-index: 1000;
            }

            .back-button {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                color: #232323;
                text-decoration: none;
                font-weight: 500;
                font-size: 16px;
                padding: 0;
                border-radius: 50%;
                transition: all 0.3s ease;
                background: rgba(255, 255, 255, 0.9);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(0, 0, 0, 0.1);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                width: 50px;
                height: 50px;
                box-sizing: border-box;
            }

            .back-button:hover {
                color: #666;
                background: rgba(255, 255, 255, 1);
                transform: translateY(-1px);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            }

            .back-button svg {
                width: 24px;
                height: 24px;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <!-- Back Button -->
            <div class="back-button-container">
                <a href="/work.html" class="back-button">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M19 12H5M12 19L5 12L12 5" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </a>
            </div>

            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <div class="lock-icon">
                            <svg width="24" height="24" viewBox="0 0 448 512" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path d="M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z" fill="#666"/>
                            </svg>
                        </div>
                        <p>This project is password protected.
						</p>
                    </div>

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Enter password"
                                autofocus
                            />
                            <p id="error-message" class="error-message">Incorrect password. Please try again.</p>
                        </div>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37591a7cfa711cf21eddf6e908ec8469e4f7774b0d4b74b6b38764d8fb5fba7c15e7117dc74d3dc1046ab8a3f59a8e3c6b3f54c530c2992641b3d04785b9cc92aae7f6bd6c1d544174e24b939e3720ca09bc93f0b4b3c71a52b8535a8fc3271acc430751826e4635092749fe50f59bae139f452587f68dca4588fa9d9e7bfd9e8d2ab8cd7393e8f7d13f6667301acc99019640c2ef0d61f1f78d44749a5980af7c8f2b3aeff9e298b675b1d36f083298fdce15fc9885f944835933ede7d880d4e02506ebb5c74243d79e453b7a1f3054af1ce02a4a6a1b22ac7f4278fc9c8ce597e598900dfb96ea649ed36c31612c6f729444189a69cae0dff32ec8349da21645d0ab9042a68e15d6d09af72db2efaa0b530fe3cb64bf6a72172395f246b9fa40159802a0701e01f37f0408e6a0f65941a9717af23a7008221d494d390c5f13c310b05e8608ce226441693845dafb6c19515ab2e9438875d4d65ea69810eafad7477e1034958cc8b98de906983120184bb68b54c0a376fa3f642b5aa15282bc85c088095b5ca86ddb969c86c8db68ec1f348ae705d2adf948b2b18221cbfea1dce920c738187adc49560620d5c08d9ec850dd3cb4ae35696866ae2e0bfb414ecb9f36190ca427cae6f7add657964cef30fa6146007f3051b8a42509418eae14b4292bcc0a7479768197ab3e2b4f3e039b4444b6ed5c0592e890cbb448c773351d6f85283183a14d279348fca7f1fb5024fb40830b28656779fda2d8cd26542e65a680a9e8fa0a267adc20997de3285abe2c75911950511fb9528da4758357df0930adc2f35c0e66cd0091826b052f0695dc913ff8601f12d91f4510fd3270882666211ab510b07402350d94dd6d1e3fb443622fbf3fd816bc4760da49f900e4381b308bd82357b701a132872a33f5b7dc8dfed145aba3f3d4159ea602eaf8085d3a6076f9e1b03191a46ad5d41fe33c9717aa2b37631bd060806633307ea52285be736f039ea4b5e0bb703a3a5bbefd1b26c63bd1ae57949e1b303d76493dca3b337316d31d02175fec98f8773ec1b2c2205dd0d0273515f1324175a9cb0605f5fb863a48cc956a6000d64df80155a67a91241f92dcb21c6374ef260e401bebbc0095246ff09adb23503c00d1cc130676d628008e939aba314e1365f70438cd495d5c295a69e394dabe3553514e69983ca4467a515d424173a942560b70b4a810d88c99c05c420cc3cf94f85d95a7cb8f2804e8f0329de8dbc28bc052edeb85bd9b79513f4a021668f7fd449338a393624691ebf5997e5ee8e451fd3e5da31494bfefa5011b8e7f48bd72dacd21f43ab2e894c664fb495084dc1e5ea120550929f6588e052768999f120dd24c6433c84826e89fbc8def91b8982dde43c7ec43fcc766cb9876dca24eab599a7766aab60ec4f02bb2db5f5171739d6d58fa313afa83cc448ca0ac816df5bc7b3850ba72881a3c1d1b7ad710ca87087103bfdb7ef1bce1ee038b92cfb38ba94f34b22f3dd5f7469859e780aa8766971b8bf9d5f027a65ac53e36eaa8b3b62e0920dd87ccc7b357916d0c088ce758cfa4e4ad1af994416a4b2a51de29368eaffc6cb2d6ce0ee6270c0cc421a3302ebc9e5cfd43ff3c79429d92aad7e4aaf7d08ce886a52a6df7831dad13e821f7ecf8e5bb283758734d53efcddffba234c7c1fc019d85b8b056e6944f94b95d0b2c13103100a4d3c13564a842fa63b69caa71b93a7fbb3e4622681dc12bdb5781bc6cf4e044f3485964d10781bc63b5fb5e9231e032285d294875068fd22104469e952bed4d4d286cde36fbe99749cbd92d1eb763fdb28f33e097b71438b0fc32764c111f47fd633ea3147133a5766ef9cfe77df27dadbab90b9da7ff52dd273a3f3e0df34f42a14ba604ee0c4f90e287b317fc40f49033943c5976f7ad5c53955019d9b3ec10b3ecd863d120e4936b1d3ac934c213d24d7d431bf315ee207bc242ba31f65724fbe9c2306e6cbc61c8ce3880deb6bedd1d8060a7b2ba8d95ad03d517677fc9f43a8a3409fb03dfbb3bda1a276ec9be8609d2f0676e0dfdcbe89d85ab7be2305003cbf193ed25e050eb729849fb879fe37044171e285f2756b42e17cc47b5f9cf7d7054fd9d6af2668f026a278217e123af288306baa35de1703ef448f3fb2c1995a51453c46fe03908d332dfec8233633ad629ca228a13c2ad09d9c4a50fae6760497734a2e825f7130c5cd3a460de2e1dcefbcdbea0358bb52e0b4a2a280cd585585cd8bd3b7aa08785ca7d6ab2d2f9cc836c6d5fd7f090495ffe415a52f43b1dd4d82561715edc78e8f4b381cb3c2705abbe8da4b3e4d8a11261b0cd5182abfcee8e806b343c90f8bffa7e14ff3bc28ec867f4f6a7f793d8e88b762c8a966fa8a426463d6e1a0c53ded7e93bb73f29fca8494c9f4e1ec6c9a8285fcfcc5a62cc09937ff3a8433111cbe8fd22e37e18bc7e670803e9679e7391358c9f43c558ade69d52b01d50137acd0df826ad688bd4da15ed9468d8e8389191e92d0dce79434502501db16d5befdd55a640ae922b5da913731f8ffd2ff52e7e855c2ca2c95ee8811029ad530d837a0c55da9cd1c37b8928657243b7021711378a182e40993faa390bb86a1933714b8e520ec8d6ee2980a62ae3fb0d494d8815842c4a73062536a54260a10488774c1261114774864ca0821558436af1c36da92157ff828386ef7df395c6d68691315be4f6cea57f7454a40bdefe30ee28bdd30c8ed3fd44ad33c9f172ff1620bfe6eb223d69b270024b3a3e910b7869be7a40880a3e2ea7ea43fde09ad40a7ff7b67109fa07d2151fe96704ce386f2f5ae6f93dfeb7b8bc967c693a3c3f6efd7cdbbaa7748853a39d9e19c75508f68037dd1caeff3a5fce0d91e75e324dea6e6164f3a54fe74ce5f83c1ff11001b7b69379073e79f94b1835328c93373ee489a0525d8b9204d830a8fa515df2086ee574d8e3d9537a8b74ebd6393b44d08ab3116b542bcaebc0bdd151544bd67677fe13775d535a6e6d0afe9eee283b93b988fd7f86adce2c015644c230124b5bea88156428de10e3c0ec073f6c3e6758a2c9749c0d731953a550b8344231c3b608e7769e72c1b72265fdb19d29488a5b0cecdb7c6d5033a1d494c56c72f416da47bbc791254bb422248b11a478eb827742f9a4753aa44a2a4546987d3bb8ed2c91406c21148c898a73f35ece98fc69b8eaf9f7ebe02b7f7486d07b7e6df24695417df3a9caba98294e0f3b99590c5fca958301aecc49da8e46c5092d181b949a17116ea3005751034f0d9684568d8e4a3a43326ec86cf2a515d7ce520efc95c26d7bdb0fec037f8de49a0cadd365175c899d106355640a925d085475ba13a9cd1a4f7c37986dde15a2af89bf69fe48518f6112860bb76e94a62d2133e105280d323a6787d1e46aee1c051fda450378ef973d881365b27d443f5c38380ec5216ca9b46dcaa3fbf821012173ee82a4e45dd228cbd609a3dd3d43642253415d38b509dd1d6979c0f4e85d3e1a0cb28926fe94d6dfe379c862d54526e27012c291ac3df6dcd034f72228990416a9e149b56a393990bf7f3fa2b3f45631f7289c3b5c5d0e3189cb435bfc2418682f5ee35fca75c9c1d5c2d9d307fa72f04f4e41ef7ff97e73ca2784c8f240f994d81374e54ab27a72df710e3f56e65ba294589bc41f2a3d89563e4fb1db036dbf52b31aeaf554d7b2ce449074f30bdd46e70d522cd84dbd16e3ce5776e3b65009aaf139592a5097226d27065bb502923e3d02b7a68a55eea936514fc2b659249beaf3d37439b7d8db085e50adbd4c43d242f2c13ee376b3746aecb61e8ad3b0a9edd59066bb702a67c06164d6182b5001df201bce458f4db2c2a368562d05884178799464dbd9fd3997f88691d38d15f468963a48d9f5e0232661527c4cd86b566705b67d986f6605b5e20c5a5f1399c562257e4c9c129ac0481cd952280629d68090d77cf17692db56050c049b9bf5bafd5f1ec331f4e1d637be0b28af1d26dc3bfc20e980bb03f8db1d07072f1ba5ca41ff64bcea520dfa79423568ebb364d44a082762e1f3ee14e98262dd07bf2f66dd748f2e9990cadb916a87e5b73d723c7b31a645c2f0a1af464e48d2886bfc621dd60cf8323ac038b7565474642fe5bf03021aaf3ccddeaf34664d0f3575d468a579e95e73583b19be03504ae4438ce7fe510fd4b355e772337e5bf8d51ad9ea8403d8228f70d378a2f79494c803f86f2d52dfc7248896deb24057a44a65cbd55dbc4085b903a2a9f9c3d41904505595ea8124dd5896b2672a0c7cdb2b3681e8ede654aa50783e80993a12f36c40ff90104dc4557d992a1e8eb370a3d44cd20e54a34c301dc6fb3d5983fe965809df2a95a9770ac0bcfde7d5ba13f887489fc2e8d45362a374e7c54eb0be04731a5da81f85394cbe49344a277331740c8d7947af3e227b814ccdfe87602af0b813c1eb25495ede2c6f5ea5a9fb840ca212b6da9481ffb10e4cda133d1e1476aada9d201ee9a8f1394f15e466deedc38af1a47a4b509d2823f9eaed55ee90a71c91dd949ce9f55dda74527ee09815952c5ebf350a70efeb694a5dccbeae39e10f7557ff44fdb67adace4c9eab67ddb49ad994c1497d91da412c1ed59c1c848291880ceb946c0b883a3b6bd0e7b37d3cc085e59c995d7f53b4a2ca39b778da8b7e426e9648eb3a18c9b49404fbd0b226a355dbd6f8df8640fbdd189787172d902a1f534d57cf5a4911cf65a1221811cb507d9f92f060b3e361a5469252291abda633d433a267e4d6e87ab592b1f65a2833754b63621a7fe4528c6a9a1b1334383beb64dba3d0d2f7bdfb063ae1f358040dadb8d815375b3b67e3a98c05878ad14dc8d9b5558428b98bb477ee465f6d63ce46b5175aea1ebb874666f921626eba7bd13b85011c094aae317b0d7a361cfb8ca34ce80e9be2cf5db8d8a6d961ee3774d27b5fae2ab306dd9231a490d09a942547dfe2a3d102101b3efe282530ec6704f5e672d7816b1a3290ac9ccb211f9ca59610a1f947dc7ab9d72425bbffa3878bf17d90054235fba298a9b4282c08fdc831608eb89fb6850433452b97cc669c1b7606c13c6ed47e9323ae1c0fae695b7da4ed6f6028c4bbbb038442c45aea15611821d814c399a54ff678349bca5a78f5ad19c31bd0136d191f89a11f9443b014c38f9b41302cc19246d2a34e791c5ba164e12e0864deb49b6ebfe810264abd7fbf1f0adb0b17b005085b38472669eac6417ee70b8f81a7dd73b70360dfa1d459db85300d7934bfb813da45f03203e529792baa432abbab6517d9bd4249a7d2a34d45c5e42dd4c3a2af96ec089865db5cb9052ddb785253d121052cc282f8c52c1d303a602c84e537ad9362eb874b156d32709298c7cf29b37262b102212781b6fc822edc7f2e954503215cd2f916649f7a31541e5eb68e073ae950b7286364c617b823502f087225e0c335d9fd7ba7ead273c9ed826a1f7c385179832195eb0e164a2aaef1800dec4f9e9125a5a588ce85ba6cc2ec054905e2eceef25560f7fb968966c685f14d9855154ae92e4242a8792925e6de70ca5658eb7bb1972d53471732f14bc16dbbe9ca9c4a318c3589269a4104431978aac46d03e0af61b6354f289eb381f63c41e612cac35d61a8d376ba38cf24d27b2854f59f99c4406e73c342f1b3c07f9b70dba4cf3268ea8b62dd0f6294f65c75664f3d5e878e1b897aae760b8e172111f55560c573231fb3147a4f6d0c5159409545f2350d4c67965ebba83b52d8f866fca56f5729cb45c8d197751a9cef9cf3bdfbe7c687d9fd259bc02cc7d700f9cfa9b0e5303b7a734b23d74e66a2b284cefd031fb9390dae8d89527abe7d222d7f6058e021087326a48f8d6241a403c80b529a910c1627c7c95c7dd7aa66c43aec1e75adcc6fd5d5e3cfbbe144a178cbe2610bac874adf99d901373219b38b181ea9f503d59e13eef32545b635ff83303fd321ff6078c6729ad273af90c0a3e888f9a9a346cd6a986fbd2cb51112c465e0c207d1b899229f0f3873d3245fd6c8a070ea7ffef1f5f507fc9b47a56f1446ffe904cd9e8069b272b809005c85e7efdfdf31f5937292afcf72eddb07043f01b0337f79caab58e9bddf2e07604d9d3760e794a90516fdd0dee907b5bb6d0a8f89bdd561f1fc76cb95d7a103e00f82ad8f528ede1551596e24e23077b099ad886bb328903cd109c8927f506f5e81d512f37fcc60ac6f3dcba8bfb8902eca98c9494a488936a8466e0be9d7cdc0d48247660127d866769e8940516b987c7303ee93ee1babc98032ac240841ef81fde3aa30de3a95a0ad3f1ff1417de42428e3d1ff82dd253b67c74dc43752b068dcd7f08ea3ef0c842881d6a02ab4aeeb31b11d2cefe8a5d21269d33ecf26f314d60b1fbff0529419d4625dcf7ba24fd91eb2bdd4609494c8a9afd098342dd98747ca66b6b6de28191ae3bd86d6d5c785e666d8e72a093f555992f5fb347231d53e52e3390a1e55da7241a1ed60ee7193e39dd14d44242cab43b05dd5e861a79e03432365041f5f9fa426fabb169472ce865383c0b158602e8d34c66c8f8b9057cc9262246ce2a832d5c0efb4c5de40a23189a199524185bfb9a4dfcfd94c5030e72185f1b9d1bb9ce63a59d446e845d945e67e2beb254ecbe2009773dc4ab8b0b6cd88d615b2ea4458ff7ebf98e7a8613b804d086d1874f5fa5d47c0fae935c651a9ed79411e77c57902be55c4cc41747b82d4d60adc2968598e41336b3da0b33c6accef326a5f087e27a5ad6c343affbbe2ddc4c480553a2f88f5c3ed14f121f3b98c05fc662694959110646877f229c0444452329ac7ff1c75691d86d42d4b20","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"65f4b3eeff9af51286876b60ca47b149"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value;
                const errorMessage = document.getElementById("error-message");

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, false);

                if (!isSuccessful) {
                    // Show error message
                    errorMessage.style.display = "block";
                    
                    // Clear password field
                    document.getElementById("staticrypt-password").value = "";
                    
                    // Disable button since field is now empty
                    const button = document.querySelector(".staticrypt-decrypt-button");
                    button.disabled = true;
                    button.style.opacity = "0.5";
                    button.style.cursor = "not-allowed";
                    
                    // Focus back on password field
                    document.getElementById("staticrypt-password").focus();
                }
            });

            // disable/enable button based on password input
            document.getElementById("staticrypt-password").addEventListener("input", function() {
                const button = document.querySelector(".staticrypt-decrypt-button");
                const password = this.value.trim();
                const errorMessage = document.getElementById("error-message");
                
                // Hide error message when user starts typing
                errorMessage.style.display = "none";
                
                if (password.length === 0) {
                    button.disabled = true;
                    button.style.opacity = "0.5";
                    button.style.cursor = "not-allowed";
                } else {
                    button.disabled = false;
                    button.style.opacity = "1";
                    button.style.cursor = "pointer";
                }
            });

            // disable button on page load
            document.addEventListener("DOMContentLoaded", function() {
                const button = document.querySelector(".staticrypt-decrypt-button");
                button.disabled = true;
                button.style.opacity = "0.5";
                button.style.cursor = "not-allowed";
            });
        </script>
    </body>
</html>
